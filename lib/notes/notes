1) ğŸ›  Problem Faced (Flutter - initState + Provider Context Error):
Tried calling Provider.of(context) inside initState, which triggered setState() or markNeedsBuild() called during build error. This happened because the widget tree wasnâ€™t fully built yet, and notifying listeners too early caused a conflict.
âœ… Solution & Why:
Wrapped the provider call inside WidgetsBinding.instance.addPostFrameCallback(...) to delay execution until after the first build. This ensured context was safely available and avoided build phase conflicts.

@override
void initState() {
  super.initState();
  WidgetsBinding.instance.addPostFrameCallback((_) {
    Provider.of<HomepageController>(context, listen: false).fetchData();
  });
}
ğŸ§  Lesson:
Always delay Provider.of(context) or any setState() logic inside initState using addPostFrameCallback when context needs to be used safely. It avoids calling build-related logic too early.



20/06/25
ğŸ”‘ Hive Update/Delete Summary (Safe Code Practices)
âœ… Problem Faced:
Used putAt(index) and delete(index)
âŒ Dangerous after deletions â€” Hiveâ€™s internal index â‰  key
âœ… Why Itâ€™s Risky:
Hive keys stay constant, but list indexes shift after delete
Can update or delete the wrong item or crash the app
âœ… Safe Solution:
Always use: final key = box.keyAt(index);
Then:
ğŸŸ¢ For update: box.put(key, updatedExpense)
ğŸŸ¢ For delete: box.delete(key)
ğŸ§¹ Controller Cleanup:
Always clear TextEditingController after use
Prevents input carryover and UI bugs
âœï¸ Prefill Editing Dialog:
Use: controller.text = oldValue; instead of hintText
Makes editing smoother and more intuitive
ğŸ”„ Always fetch after DB change:
After any update/delete, call fetchData() and notifyListeners()
ğŸ§  Memory Hook:
"List index is not Hive key â€“ always use keyAt(index) to stay safe!"

20/06/25
| Question                                    | Answer                                                                       |
| ------------------------------------------- | ---------------------------------------------------------------------------- |
| Why doesn't Hive start from 0 after delete? | Because `box.add()` uses a persistent internal counter (not reset on clear). |
| Where is this logic defined?                | Inside Hiveâ€™s internal box implementation.                                   |
| How to reset key counter?                   | Use `Hive.deleteBoxFromDisk(boxName)` â€” deletes data + resets key index.     |
| Should I worry about this in UI?            | No, as long as you map UI index â†’ `_expenseKeys[index]`.                     |
